/*
 * This Java source file was generated by the Gradle 'init' task.
 * The use of CountDownLatch helps in synchronization between threads.
 * The code is a performance testing application that sends HTTP requests to a server.
 * It uses multiple threads to simulate concurrent users making requests.
 * It measures the number of successful and failed requests, the total runtime, and the throughput.
 * Various constants are used for configuration, and the RequestSender and EventGenerator classes
 * are utilized for sending requests and generating events, respectively.
 * The program outputs the results at the end of execution.
 */
package upicclientpart1;

import java.util.concurrent.CountDownLatch;
import java.util.concurrent.atomic.AtomicInteger;
import util.EventGenerator;
import util.RequestSender;

// Main class representing the UpicClientPart1 application
public class UpicClientPart1 {
    // EC2 server path
    private static final String EC2_PATH = "http://ec2-35-87-80-19.us-west-2.compute.amazonaws.com:8080/UpicServer-1.0-SNAPSHOT";

    // Number of threads to be created
    private static final int NUM_THREADS = 32;

    // Number of requests per thread
    private static final int REQUESTS_PER_THREAD = 1000;

    // Total number of requests to be sent
    private static final int TOTAL_REQUESTS = 200000;


    // Main method
    public static void main(String[] args) throws InterruptedException {
        // Atomic counter for tracking the number of failures
        AtomicInteger failureCount = new AtomicInteger();
        // Latch for synchronization among threads
        CountDownLatch totalLatch = new CountDownLatch(NUM_THREADS * 2);
        // Latch for signaling the event generator thread to start
        CountDownLatch singleLatch = new CountDownLatch(1);

        //Create separate thread to generate events
        EventGenerator eventGenerator = new EventGenerator(TOTAL_REQUESTS);
        new Thread(eventGenerator).start();

        // Array to store threads
        Thread[] threads = new Thread[2 * NUM_THREADS];
        // Record start time for measuring runtime
        long startTime = System.currentTimeMillis();

        System.out.println("Creating threads");
        //Create and start the first set of threads
        for (int i = 0; i < NUM_THREADS; i++) {
            threads[i] = new Thread(new RequestSender(REQUESTS_PER_THREAD, totalLatch, singleLatch, EC2_PATH, i,
                failureCount, eventGenerator));
        }

        for (int i = 0; i < NUM_THREADS; i++) {
            threads[i].start();
        }
        // Wait for the event generator thread to start
        singleLatch.await();

        System.out.println("Creating additional threads");
        // Calculate average remaining requests for additional threads
        int avgRemainingRequests = (TOTAL_REQUESTS - REQUESTS_PER_THREAD * NUM_THREADS)/ NUM_THREADS;

        // Create and start the second set of threads
        for (int i = NUM_THREADS; i < 2 * NUM_THREADS; i++) {
            threads[i] = new Thread(new RequestSender(avgRemainingRequests, totalLatch, null, EC2_PATH,
                i, failureCount, eventGenerator));
        }

        for (int i = NUM_THREADS; i < 2 * NUM_THREADS; i++) {
            threads[i].start();
        }

        // Wait for all threads to finish
        totalLatch.await();

        // Record end time for measuring runtime
        long endTime = System.currentTimeMillis();

        // Output results
        System.out.println("Total number of success requests:" + (TOTAL_REQUESTS - failureCount.get()));
        System.out.println("Total number of failure requests:" + failureCount.get());
        System.out.println("Total runtime: " + (endTime - startTime)/1000 + " seconds");
        System.out.println("Total throughout: " + TOTAL_REQUESTS * 1000/(endTime - startTime) + " requests/seconds");
    }
}
